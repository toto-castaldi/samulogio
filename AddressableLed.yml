esphome:
  name: esphome-led
  includes:
    - samulogio.hpp
  on_boot:
    priority: -100
    # ...
    then:
      - light.turn_on: light_switch
      - ds1307.read_time:
# esp8266:
  # board: esp01
esp8266:
  board: nodemcuv2

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret encr_Key
ota:

wifi:
  ssid: !secret WiFi_SSID
  password: !secret WiFi_PWD

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esphome-display-test"

i2c:
  sda: 4
  scl: 5
  scan: true
  
#  id: bus_a
#captive_portal:
time:
  - platform: sntp
    id: sntp_time
    on_time_sync:
      then:
        # ... and update the RTC when the synchronization was successful
        ds1307.write_time:
  - platform: ds1307
    id: rtc_time
    address: 0x50
    update_interval: never

number:
  - platform: template
    id: hhh
    name: "Test hour"
    step: 1
    min_value: 0
    max_value: 23
    optimistic: true
  - platform: template
    id: mmm
    name: "Test minutes"
    step: 1
    min_value: 0
    max_value: 59
    optimistic: true
  - platform: template
    id: sss
    name: "Test seconds"
    step: 1
    min_value: 0
    max_value: 59
    optimistic: true


light:
  - platform: neopixelbus
    type: GRB
    variant: WS2811
    pin: GPIO14
    num_leds: 96
    name: "NeoPixel Light"
    id: light_switch
    on_turn_on:
      then:
        - light.control:
            id: light_switch
            effect: Running Dots
    effects:
      - addressable_rainbow:
      - addressable_color_wipe:
      - addressable_scan:
          scan_width: 5


      - addressable_lambda:
          update_interval: 50ms
          name: "1 Led 3 Rings"
          lambda: |-
            auto time = id(rtc_time).now();
            Color r = Color(128,0,0), g = Color(0,128,0), b = Color(0,0,128);    //should be moved to HPP
            int myH, myM, myS;
            
            it.range(0, it.size()) = Color::BLACK;
            
            myH = Get_Centerpoint(time.hour, 12, samulogio::R1, samulogio::OFFSET_R1, samulogio::START_SMALL);
            myM = Get_Centerpoint(time.minute, 60, samulogio::R2, samulogio::OFFSET_R2, samulogio::START_MID);
            myS = Get_Centerpoint(time.second, 60, samulogio::R3, samulogio::OFFSET_R3, samulogio::START_LARGE);
            
            it[myH] = b;
            it[myM] = r;
            it[myS] = g;
            
      - addressable_lambda:
          update_interval: 50ms
          name: "1 Led 1 Ring"
          lambda: |-
            auto time = id(rtc_time).now();
            Color r = Color(128,0,0), g = Color(0,128,0), b = Color(0,0,128);    //should be moved to HPP
            int myH, myM, myS;
            
            it.range(0, it.size()) = Color::BLACK;
            
            myH = Get_Centerpoint(time.hour, 12, samulogio::R1, samulogio::OFFSET_R3, samulogio::START_LARGE);
            myM = Get_Centerpoint(time.minute, 60, samulogio::R2, samulogio::OFFSET_R3, samulogio::START_LARGE);
            myS = Get_Centerpoint(time.second, 60, samulogio::R3, samulogio::OFFSET_R3, samulogio::START_LARGE);
            
            it[myH] = b;
            it[myM] = it[myM].get() + r;
            it[myS] = it[myS].get() + g;

      - addressable_lambda:
          update_interval: 1000ms
          name: "NEW clockwork"
          
          # L'idea è la seguente:
          # si definiscono un po' di const per inizio/fine dei tre display
          # myH,myM e myS rappresentano ore, minuti e secondi
          # E' sempre presente un operatore  "(x + numero - 1) % numero + 1" per far si che resto zero sia in realtà "tutto pieno"
          # Per ore e secondi è "facile"
          # Per minuti si deve prendere il resto a 5 minuti
          # Ogni 5 minuti sono 2 led (da cui il *2/5)
          # I minuti rimanenti si trasformano in secondi e gli si aggiungono i secondi 
          # Se il risultato è > 150 (= 2 min e 30 s) si aggiunge un altro led ai minuti, e si toglie 150 a questo numero
          # A questo punto questo numero (tra 0 e 150) viene usato per la luminosità
          
          
          lambda: |-
            auto time = id(rtc_time).now();
            Color r = Color(128,0,0), g = Color(0,128,0), b = Color(0,0,128);    //should be moved to HPP
            Color dr = Color (100,0,0), db = Color (0,0,50);
            int j;
            std::pair<int, int> myS, myM, myH;
            
            
            myS = GetFirstAndLastIndex(time.second, 60, samulogio::R3, samulogio::OFFSET_R3, samulogio::START_LARGE, time.second, 0);
            myM = GetFirstAndLastIndex(time.minute, 60, samulogio::R2, samulogio::OFFSET_R2, samulogio::START_MID, time.minute, 0);
            myH = GetFirstAndLastIndex(time.hour, 12, samulogio::R1,  samulogio::OFFSET_R1, samulogio::START_SMALL, time.hour, 0);
            
            ESP_LOGI("my_lib","hour %d    %d  vs %d", myH.first, myH.second, time.hour);
            ESP_LOGI("my_lib","minutes %d    %d vs %d", myM.first, myM.second, time.minute);
            ESP_LOGI("my_lib","seconds %d    %d vs %d", myS.first, myS.second, time.second);
            it.range(0, it.size()) = Color::BLACK;            
            for (j = myH.first; j != myH.second; j=(j+1)%samulogio::R1)
                it[j] = b;
            for (j = myM.first; j != myM.second; j=(j+1)%samulogio::R2)
                it[j] = r;
            for (j = myS.first; j != myS.second; j=(j+1)%samulogio::R3)
                it[j] = g;

            
            
            
      - addressable_lambda:
          update_interval: 50ms
          name: "OLD clockwork"
          
          # L'idea è la seguente:
          # si definiscono un po' di const per inizio/fine dei tre display
          # myH,myM e myS rappresentano ore, minuti e secondi
          # E' sempre presente un operatore  "(x + numero - 1) % numero + 1" per far si che resto zero sia in realtà "tutto pieno"
          # Per ore e secondi è "facile"
          # Per minuti si deve prendere il resto a 5 minuti
          # Ogni 5 minuti sono 2 led (da cui il *2/5)
          # I minuti rimanenti si trasformano in secondi e gli si aggiungono i secondi 
          # Se il risultato è > 150 (= 2 min e 30 s) si aggiunge un altro led ai minuti, e si toglie 150 a questo numero
          # A questo punto questo numero (tra 0 e 150) viene usato per la luminosità
          
          
          lambda: |-
            //costanti per numero di luci
            const int R1 = 12, R2 = 24, R3 = 60;
            const int start_small = 0;
            const int end_small = start_small - 1 + R1;
            const int start_mid = end_small + 1;
            const int end_mid = start_mid - 1 + R2;
            const int start_large = end_mid + 1;
            const int end_large = start_large -1 + R3;
            
            auto time = id(rtc_time).now();
            int myH = time.hour;
            int myM = time.minute;
            int myS = time.second;
            int lM = 0, lum = 0;
            auto r = Color(128,0,0);
            auto g = Color(0,128,0);
            auto b = Color(0,0,128);
            
            it.range(0, it.size()) = Color::BLACK;
            myH = myH % 12;
            it.range(start_small, 
                        start_small + 
                        (myH + 11) % 12 + 1) 
                    = b;
            
            lM = (((myM + 59) % 60) + 1)*2/5;
            it.range(start_mid,
                    start_mid + lM) =  r;
            lM = start_mid + lM;
            lum = myM % 5;
            lum *=60;
            lum += myS;
            //lum compreso tra 0 e 300
            if (lum >= 150)
            {
            
                lum -=150;
                it[lM] = r;
                lM++;
            }
            //lum tra 0 e 150
            lum = 128*lum/150;
            it[lM] = Color(lum,0,0);
            it.range(start_large,
                    start_large + (myS + 59) % 60 + 1) = g;

            
      - addressable_lambda:
          update_interval: 50ms
          name: "BIG RING"
          
          # L'idea è la seguente:
          # si definiscono un po' di const per inizio/fine dei tre display
          # myH,myM e myS rappresentano ore, minuti e secondi
          # E' sempre presente un operatore  "(x + numero - 1) % numero + 1" per far si che resto zero sia in realtà "tutto pieno"
          # Per ore e secondi è "facile"
          # Per minuti si deve prendere il resto a 5 minuti
          # Ogni 5 minuti sono 2 led (da cui il *2/5)
          # I minuti rimanenti si trasformano in secondi e gli si aggiungono i secondi 
          # Se il risultato è > 150 (= 2 min e 30 s) si aggiunge un altro led ai minuti, e si toglie 150 a questo numero
          # A questo punto questo numero (tra 0 e 150) viene usato per la luminosità
          
          
          lambda: |-
            //costanti per numero di luci
            const int R1 = 12, R2 = 24, R3 = 60;
            const int start_small = 0;
            const int end_small = start_small - 1 + R1;
            const int start_mid = end_small + 1;
            const int end_mid = start_mid - 1 + R2;
            const int start_large = end_mid + 1;
            const int end_large = start_large -1 + R3;
            
            auto time = id(rtc_time).now();
            int myH = time.hour;
            int myM = time.minute;
            int myS = time.second;
            int low_cut, mid_cut, high_cut;
            auto r = Color(128,0,0);
            auto g = Color(0,128,0);
            auto b = Color(0,0,128);
            auto bot = Color(128,128,128), mid = Color::BLACK, top = Color::BLACK;
            
            char myCase = 0;
            myH = myH * 5;
            myH = (myH + 59) % 60 + 1;
            myM = (myM + 59) % 60 + 1;
            myS = (myS + 59) % 60 + 1;
            
            
            myCase += (myH >= myM? 4: 0);
            myCase += (myM >= myS? 2: 0);
            myCase += (myH >= myS? 1: 0);
            switch (myCase)
            {
                case 0: //smh
                    top = g;
                    mid = top + r;
                    high_cut = myS;
                    mid_cut = myM;
                    low_cut = myH;
                    break;
                case 2: //msh
                    top = r;
                    mid = top + g;
                    high_cut = myM;
                    mid_cut = myS;
                    low_cut = myH;
                    break;
                case 3: //mhs
                    top = r;
                    mid = top + b;
                    high_cut = myM;
                    mid_cut = myH;
                    low_cut = myS;
                    break;
                case 4: //shm
                    top = g;
                    mid = top + b;
                    high_cut = myS;
                    mid_cut = myH;
                    low_cut = myM;
                    break;
               case 5: //hsm
                    top = b;
                    mid = top + g;
                    high_cut = myH;
                    mid_cut = myS;
                    low_cut = myM;
                    break;
               case 7: //hms
                    top = b;
                    mid = top + r;
                    high_cut = myH;
                    mid_cut = myM;
                    low_cut = myS;
                    break;
            }
            it.range(0, it.size()) = Color::BLACK;
            it.range(start_large, start_large + low_cut) = bot;
            it.range(start_large + low_cut, start_large + mid_cut) = mid;
            it.range(start_large + mid_cut, start_large + high_cut) = top;

            
            
      - addressable_lambda:
          update_interval: 1000ms
          name: "test"
          
          lambda: |-
            Color r = Color(128,0,0), g = Color(0,128,0), b = Color(0,0,128);    //should be moved to HPP
            int myH, myM, myS;
            
            it.range(0, it.size()) = Color::BLACK;
            
            myH = Get_Centerpoint(id(hhh).state, 12, samulogio::R1, samulogio::OFFSET_R1, samulogio::START_SMALL);
            myM = Get_Centerpoint(id(mmm).state, 60, samulogio::R2, samulogio::OFFSET_R2, samulogio::START_MID);
            myS = Get_Centerpoint(id(sss).state, 60, samulogio::R3, samulogio::OFFSET_R3, samulogio::START_LARGE);
            
            
            it[myH] = b;
            it[myM] = r;
            it[myS] = g;
            
            
web_server:
  port: 80